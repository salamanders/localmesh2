<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>Disco Ball</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
<script src="three.min.js"></script>
<script>
    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 17;

    const renderer = new THREE.WebGLRenderer({ /*antialias: true*/ });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const textureLoader = new THREE.TextureLoader();
    const reflectionMap = textureLoader.load('discoball_reflection.png');
    reflectionMap.mapping = THREE.EquirectangularReflectionMapping;
    reflectionMap.wrapS = THREE.RepeatWrapping; // Enable horizontal wrapping

    // scene.background = reflectionMap;

    // Disco Ball Material
    const material = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 1.0, // Max metalness for full reflection
        roughness: 0.0, // Min roughness for sharp reflection
        envMap: reflectionMap,
        flatShading: true // This will make the individual faces more distinct
    });

    const discoBall = new THREE.Group();
    const radius = 10;
    const tileSize = 0.8; // As requested by the user
    const tileGeom = new THREE.BoxGeometry(tileSize, tileSize, 0.1);

    let row = 0;
    for (let phi = 0; phi < Math.PI; phi += Math.PI / 40) {
        const circumference = 2 * Math.PI * radius * Math.sin(phi);
        const numTiles = Math.floor(circumference / tileSize);
        const thetaStep = (2 * Math.PI) / numTiles;
        const thetaOffset = (row % 2 === 0) ? 0 : thetaStep / 2;

        for (let i = 0; i < numTiles; i++) {
            const theta = i * thetaStep + thetaOffset;
            const x = radius * Math.cos(theta) * Math.sin(phi);
            const z = radius * Math.sin(theta) * Math.sin(phi);
            const y = radius * Math.cos(phi);
            const tile = new THREE.Mesh(tileGeom, material);
            tile.position.set(x, y, z);
            tile.lookAt(0, 0, 0);
            discoBall.add(tile);
        }
        row++;
    }
    scene.add(discoBall);

    // Lighting
    // const ambientLight = new THREE.AmbientLight(0x404040, 2); // soft white light
    // scene.add(ambientLight);

    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.0005;
        // Slowly scroll the reflection map
        // reflectionMap.offset.x += 4 * time;
        // Slow horizontal rotation
        discoBall.rotation.y += 0.005;
        renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }, false);

    animate();
    console.log('LOCALMESH_SCRIPT_SUCCESS:disco3');
</script>
</body>
</html>
